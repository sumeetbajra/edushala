var util = require('util');
// Export the factory function.
exports.createAppError = createAppError;

// Export the constructor function.
exports.AppError = AppError;


// ----------------------------------------------------------------------------------- //
// ----------------------------------------------------------------------------------- //


// I create a new instance of the AppError object.
function createAppError(settings, data) {
    // NOTE: We are overriding the "implementationContext" so that the createAppError()
    // function is not part of the resulting stack trace.
    return (new AppError(settings, data, createAppError));

}

// I am the custom error object for the application. The settings is a hash of optional
// properties for the error instance:
// --
// * type: I am the type of error being thrown.
// * message: I am the reason the error is being thrown.
// * detail: I am an explanation of the error.
// * extendedInfo: I am additional information about the error context.
// * errorCode: I am a custom error code associated with this type of error.
// * rootCause: I am the originating error that is being wrapped up in a new error.
// --
// NOTE: The implementationContext argument is an optional argument that can be used
// to trim the generated stack trace. If not provided, it defaults to AppError.
function AppError(settings, data, implementationContext) {

    if (typeof (settings) === 'string')
        settings = { message: settings };

    // Ensure that settings exists to prevent reference errors.
    settings = (settings || {});
    if (data)
        settings.data = data;
    this.success = false;
    this.is_error = true;
    this.is_rs = (settings.is_rs == undefined) ? true : settings.is_rs;
    // Override the default name property (Error). This is basically zero value-add.
    this.name = (settings.name || "");

    // Set up the sub-classed error properties.
    this.type = (settings.type || "application");
    this.message = (settings.message || settings.msg ||"An error occurred.");
    this.detail = (settings.detail || "");
    this.status = (settings.status || 500);
    this.code = (settings.code || "");
    this.data = (settings.data || {});
    this.multi_errors = (settings.multi_errors || settings.multi || []);

    // I am the originating error object that is being wrapped up. This allows each
    // error instance to include additional information without losing insight into the
    // original error deep down in the call stack.
    this.root_cause = (settings.root_cause || null);

    // This is just a flag that will indicate if the error is a custom AppError.
    this.getSourceFile = function() {
        var originalFunc = Error.prepareStackTrace;

        var callerfile;
        try {
            var err = new Error();
            var currentfile;

            Error.prepareStackTrace = function (err, stack) { return stack; };

            currentfile = err.stack.shift().getFileName();

            while (err.stack.length) {
                callerfile = err.stack.shift().getFileName();

                if (currentfile !== callerfile) break;
            }
        } catch (e) { }

        Error.prepareStackTrace = originalFunc;

        return callerfile;
    }

    // Capture the current stack trace and store it in the property "this.stack". By
    // providing the implementationContext argument, we will remove the current
    // constructor (or the optional factory function) line-item from the stack trace;
    // this is good because it will reduce the implementation noise in the stack property.
    Error.captureStackTrace && Error.captureStackTrace(this, (implementationContext || AppError));

}

util.inherits(AppError, Error);


/*
//Reference
//https://www.bennadel.com/blog/2886-experimenting-with-russian-doll-error-reporting-in-node-js.htm
//https://gist.github.com/justmoon/15511f92e5216fa2624b For test script as well
var util = require("util");
var classy = require("classy");

function _getCallerFile() {
    var originalFunc = Error.prepareStackTrace;

    var callerfile;
    try {
        var err = new Error();
        var currentfile;

        Error.prepareStackTrace = function (err, stack) { return stack; };

        currentfile = err.stack.shift().getFileName();

        while (err.stack.length) {
            callerfile = err.stack.shift().getFileName();

            if (currentfile !== callerfile) break;
        }
    } catch (e) { }

    Error.prepareStackTrace = originalFunc;

    return callerfile;
}

var error = classy.define({
    extend: Error,
    forceInstance: true,
    init: function (settings) {
        if (typeof (settings) === 'string')
            settings = { message: settings };

        // Ensure that settings exists to prevent reference errors.
        settings = (settings || {});

        // Override the default name property (Error). This is basically zero value-add.
        this.name = "RSError";

        // Set up the sub-classed error properties.
        this.type = (settings.type || "Application");
        this.message = (settings.message || "An error occurred.");
        this.detail = (settings.detail || "");
        this.code = (settings.code || "");
        this.data = (settings.data || {});
        this.multi_errors = (settings.multi_errors || []);

        // I am the originating error object that is being wrapped up. This allows each
        // error instance to include additional information without losing insight into the
        // original error deep down in the call stack.
        this.root_cause = (settings.root_cause || null);

        // This is just a flag that will indicate if the error is a custom AppError.
        this.is_rs = true;
        this.test = _getCallerFile();

        // Capture the current stack trace and store it in the property "this.stack". By
        // providing the implementationContext argument, we will remove the current
        // constructor (or the optional factory function) line-item from the stack trace;
        // this is good because it will reduce the implementation noise in the stack property.
        Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
    }
})

module.exports = error;
*/