var seriate = require("seriate");
var rs = require('../misc/rs');
var modelCls = require('../model');

var mappings = {
    default: "NVARCHAR",
    string: "NVARCHAR",
    select: "NVARCHAR",
    email: "NVARCHAR",
    varchar: "NVARCHAR",
    nvarchar: "NVARCHAR",
    text: "NVARCHAR",
    url: "NVARCHAR",
    int: "INT",
    tinyint: "INT",
    smallint: "INT",
    number: "BIGINT",
    long: "BIGINT",
    identity: "BIGINT",
    date: "DATE",
    datetime: "DATETIME2",
    guid: "UNIQUEIDENTIFIER",
    bool: "BIT",
    boolean: "BIT"
};

var sqlerr = function (err) {
    var formattedMsg = rs.util.getPlaceholder(err.message);
    var jMsg = { msg: err.message };
    try {
        if (formattedMsg.length > 0)
            jMsg = JSON.parse('{' + formattedMsg + '}');
        else
            jMsg.message = rs.util.getPlaceholder(err.message, /with: \"(.*?)\"/g)[0];
    } catch (ex) { }
    return rs.error({ name: jMsg.name, detail: err.message || jMsg.msg, msg: jMsg.message || jMsg.msg, type: 'db', code: err.code, root_cause: err });
};

var mssql = rs.classy.define({
    forceInstance: true,
    mappings: mappings,
    init: function (cfg) {
        rs.util.apply(this, cfg);

        //apply default pool. Can be overwritten from config
        this.conn = rs.apply({
            pool: {
                max: 10,
                min: 4,
                idleTimeoutMillis: 30000
            }
        }, this.conn);
        seriate.addConnection(this.conn);
        this.seriate = seriate;
        rs.util.apply(this.mappings, this.custom_mappings);
    },
    convertType: function (type) {
        var mtype;
        mtype = mappings[type];
        if (!mtype)
            mtype = mappings["default"];
        return seriate[mtype];
    },

    getFormattedData: function (model, fieldStr) {
        if (!model.data)
            throw rs.error('Model must have data');

        var params = {};
        var fields = null;
        if (fieldStr)
            fields = fieldStr.split(',');
        for (var f in model.schema) {
            if (fields)
                if (!rs.util.array.exists(fields, f)) { continue; };
            params[f] = {
                val: model.data[f],
                type: this.convertType(model.schema[f].type)
            };
        }
        return params;
    },

    formatter: function (c) {

        if(!c.formatter)
            return c.data;
        var data = c.data;
        for (var key in c.formatter) {
            if (data[key]) {
                if (typeof (c.formatter[key]) == 'string') {
                    if (c.formatter[key] == 'json')
                        data[key] = JSON.parse(data[key])
                } else {
                    data[key] = c.formatter[key](data[key]);
                }
            }
        }
        return data;
    },

    cleanResult: function (r, c) {
        var return_data = null;
        c = c || {};

        return_data = r[0];
        if (!return_data[0])
            return [];
        return_data = return_data[0];

        if(!Array.isArray(return_data)){
            return return_data;
        }

        //limit formatting
        if(return_data.length>25){
            return return_data;
        }



        for(var i in return_data){
            return_data[i] = this.formatter({formatter: c.formatter, data: return_data[i]});
        }

        return return_data;
    },

    get: function (c, cm) {
        if(cm)
            rs.apply(c,cm);
        var success = c.success;
        c.success = function (r) {
            if(Array.isArray(r))
                success(r[0]);
            else
                success(r);
        };
        this.execute(c);
    },

    list: function (c, cm) {
        this.execute(c, cm);
    },

    execute: function (c, cm) {
        var me = this;
        if(cm)
            rs.apply(c,cm);
        if (c.procedure)
            rs.apply(c, { procedure: c.procedure });
        else {
            if(!c.query)
                throw rs.error('Must send a either a procedure or a query');
            rs.apply(c, {query: c.query});
        }

        if(!c.model){
            if(c.schema) {
                c.model = modelCls({
                    schema: c.schema,
                    data: c.data
                });
                c.model.validate();
            }
        }

        if(c.model)
            c.params = this.getFormattedData(c.model, c.fields);

        seriate.execute(this.conn, c).then(function (results) {
            if (!results)
                results = {null_results:true};
            if(c.success) {
                if (c.procedure)
                    c.success(me.cleanResult(results, c));
                else
                    c.success(results);
            }
        }, function (error) {
            if(c.failure)
                c.failure(sqlerr(error))
        })
    }
});

module.exports = mssql;