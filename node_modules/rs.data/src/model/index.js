var rs = require('../misc/rs');
var validations = require('./validations');

var default_fields = {
    is_active: { name: 'is_active', type: 'bool', nullable: false, default: true },
    date_added: { name: 'date_added', type: 'datetime', nullable: false, default: 'now' }
};

var named_fields = {
    start: {name: 'start', type: 'int', required: true, default: 0},
    limit: {name: 'limit', type: 'int', required: true, default: 25},
    is_active: { name: 'is_active', type: 'bool', nullable: false, default: true },
    date_added: { name: 'date_added', type: 'datetime', nullable: false, default: 'now' },
    session_id: {name: 'session_id', type: 'long', required: true}
};

var statics = {
    //modified version of rs.util.applyDefaults
    cleanSchema: function (parent, options) {
        options = options || {};
        var new_obj = {};
        //apply defaults to all the relevant childern
        for (var child_name in parent) {
            var child = parent[child_name]
            if (child_name.substring(0, 1) != '_') {
                new_obj[child_name] = {};
            }
            if (options.addDefaults)
                rs.util.apply(new_obj[child_name], { id: { name: 'id', type: 'identity', primary_key: true } });
            for (var gchild_name in child) {
                var parent_defaults = rs.util.apply({ name: gchild_name }, parent._defaults);
                var child_defaults = rs.util.apply(parent_defaults, child._defaults);
                var gchild = child[gchild_name];
                gchild = rs.util.apply(child_defaults, gchild);
                if (child_name.substring(0, 1) != '_' && gchild_name.substring(0, 1) != '_') {
                    new_obj[child_name][gchild_name] = gchild;
                }
            }
            if (options.addDefaults)
                rs.util.apply(new_obj[child_name], default_fields);
        }
        return new_obj;
    }
};

var model = rs.classy.define({
    forceInstance: true,
    addDefaultFields: false,
    autoFix: true,
    autoValidation: true,
    errors: null,
    schema: null,
    validations: [],
    statics: statics,
    init: function (config) {
        rs.util.requireProperty(config, 'schema');

        rs.util.apply(this, config);
        this.isModel = true;
        this.name = config.name || null;
        this.data = config.data || null;
        this.namedFields = config.namedFields || {};
        rs.util.apply(this.namedFields, named_fields);

        this.sanitizeSchema();

        //check schema
        this.validateSchema(this.schema);
        
        //add default schema items
        if (this.addDefaultFields)
            rs.util.apply(this.schema, default_fields);

        //enable validation
        this.validations = validations;

        //data validation
        if (this.autoValidation && this.data)
            this.validate(this.data);
    },
    sanitizeSchema: function () {
        if (!this.autoFix)
            return;
        //convert array into object
        if (Array.isArray(this.schema))
        {
            var orig_schema = this.schema;
            this.schema = {};
            for (var i in orig_schema) {
                var item = orig_schema[i];
                if (typeof (item) === 'string') {
                    if(named_fields[item]){
                        item = this.namedFields[item];
                    } else {
                        var n_item = {
                            name: item
                        };
                        item = n_item;
                    }
                }
                if (item.required != false)
                    item.required = true;
                this.schema[item.name] = item;
            }
        }

        for (var f in this.schema) {
            rs.util.apply(this.schema[f], { name: f });
            if (!this.schema[f].type)
                rs.util.apply(this.schema[f], { type: 'string' });
            if (this.requireAll === true)
                rs.util.apply(this.schema[f], { required: true });
        }
    },
    addError: function (err) {
        if (!this.errors)
            this.errors = [];
        this.errors.push(err);
    },

    addData: function (data) {
        this.data = data;
        this.validate(this.data);
    },

    addSchema: function (schema) {
        schema = rs.util.array.ensure(schema);

        for (var i in schema) {
            var item = schema[i];
            if (typeof (schema[i]) == 'string') {
                item = {
                    name: schema[i],
                    type: 'string'
                }
            }

            rs.util.requireProperty(item, 'name');
            this.schema[item.name] = item;
        }
    },

    getSchema: function () {
        return this.schema;
    },

    validate: function (data) {
        this.data = data || this.data;
        if (!this.data)
            throw new Error('Model must have data to validate');
        for (var field_name in this.schema) {
            for (var v in this.validations) {
                this.validations[v](this.data[field_name], this.schema[field_name], field_name, this.data, this);
            }
        }
        if (this.errors)
            throw rs.error({ message: 'Error validating model', multi_errors: this.errors });
    },

    validateSchema: function (schema) {
        for (var f in schema) {
            if (f === '_defaults') { continue; };
            if (!schema[f].type)
                throw new Error('Schema is missing type. [' + f + ']');
            if (!schema[f].name)
                throw new Error('Schema is missing name. [' + f + ']');
        }
    }
});

module.exports = model;